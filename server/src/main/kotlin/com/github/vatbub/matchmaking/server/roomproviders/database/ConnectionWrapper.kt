package com.github.vatbub.matchmaking.server.roomproviders.database

import java.sql.Connection
import java.sql.Savepoint
import java.util.*
import java.util.concurrent.Executor

class ConnectionWrapper(
    private val wrappedConnection: Connection,
    private val onClose: ((connection: Connection) -> Unit)? = null
) : Connection {
    override fun prepareStatement(sql: String?) = wrappedConnection.prepareStatement(sql)

    override fun prepareStatement(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ) = wrappedConnection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

    override fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int) =
        wrappedConnection.prepareStatement(sql, resultSetType, resultSetConcurrency)

    override fun prepareStatement(sql: String?, autoGeneratedKeys: Int) =
        wrappedConnection.prepareStatement(sql, autoGeneratedKeys)

    override fun prepareStatement(sql: String?, columnIndexes: IntArray?) =
        wrappedConnection.prepareStatement(sql, columnIndexes)

    override fun prepareStatement(sql: String?, columnNames: Array<out String>?) =
        wrappedConnection.prepareStatement(sql, columnNames)

    override fun rollback() = wrappedConnection.rollback()

    override fun rollback(savepoint: Savepoint?) = wrappedConnection.rollback(savepoint)

    override fun getHoldability() = wrappedConnection.holdability

    override fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        wrappedConnection.setNetworkTimeout(executor, milliseconds)
    }

    override fun commit() = wrappedConnection.commit()

    override fun <T : Any?> unwrap(iface: Class<T>?) = wrappedConnection.unwrap(iface)

    override fun setTransactionIsolation(level: Int) {
        wrappedConnection.transactionIsolation = level
    }

    override fun setAutoCommit(autoCommit: Boolean) {
        wrappedConnection.autoCommit = autoCommit
    }

    override fun abort(executor: Executor?) {
        wrappedConnection.abort(executor)
    }

    override fun prepareCall(sql: String?) = wrappedConnection.prepareCall(sql)

    override fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int) =
        wrappedConnection.prepareCall(sql, resultSetType, resultSetConcurrency)

    override fun prepareCall(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ) = wrappedConnection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

    override fun getClientInfo(name: String?) = wrappedConnection.getClientInfo(name)

    override fun getClientInfo() = wrappedConnection.clientInfo

    override fun getAutoCommit() = wrappedConnection.autoCommit

    override fun setCatalog(catalog: String?) {
        wrappedConnection.catalog = catalog
    }

    override fun getWarnings() = wrappedConnection.warnings

    override fun getCatalog() = wrappedConnection.catalog

    override fun setHoldability(holdability: Int) {
        wrappedConnection.holdability = holdability
    }

    override fun getSchema() = wrappedConnection.schema

    override fun isValid(timeout: Int) = wrappedConnection.isValid(timeout)

    override fun close() {
        onClose?.invoke(wrappedConnection)
        wrappedConnection.close()
    }

    override fun isClosed() = wrappedConnection.isClosed

    override fun createNClob() = wrappedConnection.createNClob()

    override fun createBlob() = wrappedConnection.createBlob()

    override fun createArrayOf(typeName: String?, elements: Array<out Any>?) =
        wrappedConnection.createArrayOf(typeName, elements)

    override fun setReadOnly(readOnly: Boolean) {
        wrappedConnection.isReadOnly = readOnly
    }

    override fun isWrapperFor(iface: Class<*>?) = wrappedConnection.isWrapperFor(iface)

    override fun nativeSQL(sql: String?) = wrappedConnection.nativeSQL(sql)

    override fun createStruct(typeName: String?, attributes: Array<out Any>?) =
        wrappedConnection.createStruct(typeName, attributes)

    override fun setClientInfo(name: String?, value: String?) {
        wrappedConnection.setClientInfo(name, value)
    }

    override fun setClientInfo(properties: Properties?) {
        wrappedConnection.clientInfo = clientInfo
    }

    override fun releaseSavepoint(savepoint: Savepoint?) = wrappedConnection.releaseSavepoint(savepoint)

    override fun createClob() = wrappedConnection.createClob()

    override fun isReadOnly() = wrappedConnection.isReadOnly

    override fun createStatement() = wrappedConnection.createStatement()

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int) =
        wrappedConnection.createStatement(resultSetType, resultSetConcurrency)

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) =
        wrappedConnection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)

    override fun setSavepoint() = wrappedConnection.setSavepoint()

    override fun setSavepoint(name: String?) = wrappedConnection.setSavepoint(name)

    override fun getTypeMap() = wrappedConnection.typeMap

    override fun clearWarnings() = wrappedConnection.clearWarnings()

    override fun getMetaData() = wrappedConnection.metaData

    override fun getTransactionIsolation() = wrappedConnection.transactionIsolation

    override fun setSchema(schema: String?) {
        wrappedConnection.schema = schema
    }

    override fun getNetworkTimeout() = wrappedConnection.networkTimeout

    override fun setTypeMap(map: MutableMap<String, Class<*>>?) {
        wrappedConnection.typeMap = typeMap
    }

    override fun createSQLXML() = wrappedConnection.createSQLXML()
}